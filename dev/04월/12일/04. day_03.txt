- 이해를 돕는 이미지 추가 예정

-> 14강: 큐(Queues)

 =========================================== 추가 예정 ===========================================




-> 15강: 환형 큐 (Circular Queue)

  - 큐에 담을 수 있는 데이터의 양 (우리 강의에서 이용하는 용어를 가져다 쓰자면, "데이터 원소의 개수")
    이 무한할 수는 없을 것입니다. 
    만약 큐에 담을 수 있는 원소의 개수의 상한을 미리 정하고 이를 지킬 수 있다면, 선형 배열을 이용해서 
    큐를 효과적으로 구현할 수 있습니다. 선형 배열의 한쪽 끝과 다른 쪽 끝이 서로 맞닿아 있는 모습 
    ("원형" 또는 "환형") 으로 생각하고, 큐의 맨 앞과 맨 뒤를 가리키는 (즉, 원소를 넣을 쪽의 배열 
    인덱스와 꺼낼 쪽의 배열 인덱스를) 기억해 두면, 데이터 원소가 빠져 나간 쪽의 저장소를 재활용하면서 
    큐를 관리할 수 있습니다.

    이러한 모습으로 구성한 큐를 환형 큐 (circular queue) 라고 부릅니다. 이 강의에서는 환형 큐의 
    운용에 대하여 배워보고, 연습문제로 환형 큐를 추상적 자료구조로 구현해봅니다.


-> 16강: 우선순위 큐 (Priority Queues)

  - 큐가 FIFO(First-In First-Out) 방식을 따르지 않고 원소들의 우선순위에 따라 큐에서 빠져나오는 방식
    * 활용 예) 운영체제의 CPU 스케줄러
  - 복잡도 유리: enqueue할 때 sort하는 것이 유리(dequeue보다)
  - 구현 예) (1)선형 배열 이용, (2) 연결 리스트 이용
  - 



-> 17강: 트리 (Tree)

 - 정점(node)과 간선(edge)을 이용한 데이터의 배치 형태를 추상화한 자료구조
 - 부모노드 자식노드의 관계(*root노드)
 - root노드부터 level 0 ~ 밑으로 갈수록 level += 1
 - 트리 높이(Height) == 깊이(depth) => max level + 1
 - 부분트리(subtree) 
 - 차수(degree) = 자식(subtree)의 수 (자식 노드를 몇개 가지고 있는가)
   - 해당 노드는 부모노드는 하나만(유일한) 자식노드는 여러개 간선으로 연결 가능하다
 - 이진 트리(Binary Tree): 모든 노드의 차수가 2이하인 트리

 - 포화 이진 트리(Full Binary Tree): 모든 레벨에서 노드들이 모두 채워져 있는 이진 트리
   (높이가 k이고 노드의 개수가 2^k-1인 이진트리)
 - 완전 이진 트리(Complete Binary Tree): 높이 k인 완전 이진 트리
   레벨 k-2까지는 모든 노드가 2개의 자식을 가진 포화 이진 트리
   레벨 k-1에서는 왼쪽부터 노드가 순차적으로 채워져 있는 이진 트리



-> 18강: 이진 트리 (Binary Tree)

 - 이진 트리의 추상적 자료구조
   - 연산의 정의
    - size() - 현재 트리에 포함되어 있는 노드의 수를 구함(subtree(left) + subtree(right) + 1)
    - depth() - 현재 트리의 깊이(or Height)를 구함(max(subtree(left),subtree(right)) +1)
    - 순회(traversal) 

    ***깊이우선순회(dft) - <재귀>
      - 중위순회(In-order): 
         (1) Left subtree
         (2) 자기자신
         (3) Right subtree                        
      - 전위순회(Pre-order): *실습
         (1) 자기자신
         (2) Left subtree
         (3) Right subtree    
      - 후위순회(Post-order): *실습
         (1) Left subtree
         (2) Right subtree 
         (3) 자기자신


-> 19강: 이진 트리 - 넓이 우선 순회(breadth first traversal)

 **넓이우선순회(bft) - <deque>
 - 원칙
  - 수준(level)이 낮은 노드를 우선으로 방문
  - 같은 수준의 노드들 사이에는,
   - 부모 노드의 방문 순서에 따라 방문 
     왼쪽 자식노드를 오른쪽 자식보다 먼저 방문
   

-> 20강: 이진 탐색 트리(Binary Search Trees)(1)

 - 모든 노드에 대해서 왼쪽 서브트리에 들어 있는 데이터는 모두 현재 노드의 값 (키) 보다 작고      
   오른쪽 서브트리에 들어 있는 데이터는 모두 현재 노드의 값 (키) 보다 크도록 트리를 유지합니다. 
   다시 말하면, 이러한 성질을 만족하는 이진 트리를 이진 탐색 트리라고 부릅니다.

  - 연산의 정의
   - insert(key,data) - 트리에 주어진 데이터 원소를 추가
   - remove(key) - 특정 원소를 트리로부터 삭제
   - lookup(key) - 특정 원소를 검색
   - inorder() - 키의 순서대로 데이터 원소를 나열
   - min(), max() - 최소 키, 최대 키를 가지는 원소를 각각 탐색


-> 21강: 이진 탐색 트리(Binary Search Trees)(2)

 - 삭제되는 노드가 
  1. 말단(leaf) 노드인 경우
    - 그냥 그 노드를 없애고 부모 노드의 링크를 조정(좌?우?)

  2. 자식을 하나가지고 있는 경우
    - 삭제되는 노드 자리에 그 자식을 대신 배치
     -> 자식이 왼쪽? 오른쪽?
     -> 부모 노드의 링크를 조정(좌?우?)

  3. 자식을 둘 가지고 있는 경우

  ** 발전학습 주제
   - 높이의 균형을 유지함으로써 O(logn)의 탐색 복잡도 보장 삽입,삭제 연산이 보다 복잡
    - AVL trees, Red-black trees


-> 22강: 힙(Heaps)

 - 이진 트리의 한 종류 (이진 힙 - Binary heap)
  1. 루트(root)노드가 언제나 최대값 또는 최소값을 가짐
    - 최대 힙(max heap), 최소 힙(min heap)
  2. 완전 이진 트리여야 함

 - 최대 힙: 원소 삽입
  1. 트리의 마지막 자리에 새로운 원소를 임시로 저장
  2. 부모 노드와 키 값을 비교하여 위로, 위로, 이동
  - 복잡도: 부모 노드와의 대소 비교 최대 회수: log(2)n
   * 최악: O(logn)
  * 실습



-> 23강: 힙(Heaps)(2)

 - 최대 힙: 원소 삭제
  1. 루트 노드의 제거 - 이것이 원소들 중 최댓값
  2. 트리 마지막 자리 노드를 임시로 루트 노드의 자리에 배치
  3. 자식 노드들과의 값 비교와 아래로, 아래로 이동
   - 자식은 둘 있을 수도 있는데, 어느 쪽으로 이동?: 더 큰 키 값을 가지는 쪽으로!
  - 복잡도: 자식 노드들과 대소 비교 회수: 2*log(2)n
   * 최악: O(logn)

  * 실습

  **최대/최소 힙의 응용

   1. 우선 순위 큐(Priority queue)
    - Enequeue 할 때 "느슨한 정렬"을 이루고 있도록 함: O(logn)
    - Dequeue 할 때 최대값을 순서대로 추출: O(logn)
    - 양방향 연결 리스트 이용 구현과 효율성 비교(시간적으로 장점)

   2. 힙 정렬(heap sort)
    - 정렬되지 않은 원소들을 아무 순서로나 최대 힙에 삽입: O(logn) 
    - 삽입이 끝나면, 힙이 비게 될때까지 하나씩 삭제: O(logn) 
    - 원소들이 삭제된 순서가 원소들의 정렬 순서
    - 정렬 알고리즘의 복잡도: O(nlogn)









- 14~23강 문제풀이 & 프로그래머스 레벨 2 풀기
- 문제 많이 풀자~ 프로그래머스 레벨 3 쉽게 풀 때까지...
