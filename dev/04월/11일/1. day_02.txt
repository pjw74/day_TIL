--------------------시작------------------------
hello world

- 7강: 연결 리스트(Linked Lists)(1) ->


- 8강: 연결 리스트(Linked Lists)(2) ->


- 9강: 연결 리스트(Linked Lists)(3) ->


- 10강: 양방향 연결 리스트(Doubly Linked Lists) ->


- 11강: 스택(Stacks) (LIFO; last-in first-out) ->
 - size(): 현재 스택에 들어 있는 데이터 원소의 수를 구함
 - isEmpty(): 현재 스택이 비어 있는지를 판단(size() == 0?)
 - push(x): 데이터 원소 x를 스택에 추가
 - pop(): 스택에 가장 나중에 저장된 데이터 원소를 제거(또한, 반환)
 - peek(): 스택에 가장 나중에 저장된 데이터 원소를 참조(반환), 그러나 제거하지는 않음

- 12강: 수식의 후위 표기법 ->
 - 중위 표기법(infix notation): 연산자가 피연산자들의 사이에 위치
 - 후위 표기법(postfix notation): 연산자가 피연산자들의 뒤에 위치

 * 피연산자 적고 연산자는 스택을 이용하여 우선순위가 높으면 pop() 낮으면 push()
  ex)
   [중위] A*B+C  [중위] A+B*C  [중위] A+B+C 
   [후위] AB*C+  [후위] ABC*+  [후위] AB+C+      

   
 * 여는 괄호는 스택에 push(), 닫는 괄호를 만나면 여는 괄호가 나올 때까지 pop()
  ex)
   [중위] (A+B)*C  [중위] A*(B+C)
   [후위] AB+C*    [후위] ABC+*


 예제 1)
  [중위] (A+B)*(C+D)
  [후위] AB+CD+*

 예제 2)
  [중위] (A+(B-C))*D  [중위] A*(B-(C+D))
  [후위] ABC-+D*      [후위] ABCD+-*

- 13강: 후위 표기 수식 계산 ->
 - 계산 방법: Stack을 이용(피연산자 만나면 push() 연산자 만나면 (1) pop(), (2) pop() 
             (2) 연산자 (1)을 계산(Stack에 먼저 들어간 (2) 앞에 계산))

 











- 7~13강 문제풀이 & 프로그래머스 레벨 2 풀기
- 문제 많이 풀자~ 프로그래머스 레벨 3 쉽게 풀 때까지...
